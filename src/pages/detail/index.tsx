import { useEffect, useRef, useState, useCallback } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { addToast } from "@heroui/toast";
import * as cornerstone from "@cornerstonejs/core";
import {
  RenderingEngine,
  Enums,
  init as csRenderInit,
} from "@cornerstonejs/core";
import {
  init as csToolsInit,
  addTool,
  PanTool,
  WindowLevelTool,
  ZoomTool,
  LengthTool,
  RectangleROITool,
  EllipticalROITool,
  CircleROITool,
  PlanarFreehandROITool,
  ArrowAnnotateTool,
  ProbeTool,
  AngleTool,
  BidirectionalTool,
  CobbAngleTool,
  RectangleROIStartEndThresholdTool,
  RectangleROIThresholdTool,
  SplineROITool,
  LivewireContourTool,
  MagnifyTool,
  OverlayGridTool,
  ScaleOverlayTool,
  AdvancedMagnifyTool,
  UltrasoundDirectionalTool,
  RectangleScissorsTool,
  CircleScissorsTool,
  SphereScissorsTool,
  LabelTool,
  ToolGroupManager,
  Enums as ToolsEnums,
  annotation as csToolsAnnotation,
} from "@cornerstonejs/tools";
import dicomImageLoader, {
  init as dicomImageLoaderInit,
} from "@cornerstonejs/dicom-image-loader";
import * as dicomParser from "dicom-parser";
import {
  getOriginalDataDetailRequest,
  type DcmData,
  saveDcmAnnotationsRequest,
} from "@/api/dcm";
import TopBar from "./components/TopBar";
import ToolBar from "./components/ToolBar";
import StatusBanners from "./components/StatusBanners";
import ViewerCanvas from "./components/ViewerCanvas";
import ImageSwitcher from "./components/ImageSwitcher";

const { ViewportType } = Enums;
const { MouseBindings } = ToolsEnums;

// å·¥å…·æ˜¾ç¤ºä¸è¯´æ˜å·²æ‹†åˆ†åˆ°ç»„ä»¶å†…éƒ¨

function DetailPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const elementRef = useRef(null);
  const [isLoading, setIsLoading] = useState(false);
  const [dataLoading, setDataLoading] = useState(true); // æ•°æ®åŠ è½½çŠ¶æ€
  const [error, setError] = useState(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [activeTool, setActiveTool] = useState("WindowLevel"); // å½“å‰æ¿€æ´»çš„å·¥å…·
  const [dcmData, setDcmData] = useState<DcmData | null>(null); // DCMæ•°æ®
  const [currentImageIndex, setCurrentImageIndex] = useState(0); // å½“å‰å›¾åƒç´¢å¼•
  const [imageIds, setImageIds] = useState<string[]>([]); // å›¾åƒ IDåˆ—è¡¨
  const [isImageControlExpanded, setIsImageControlExpanded] = useState(false); // å›¾åƒåˆ‡æ¢æ§ä»¶å±•å¼€çŠ¶æ€
  const renderingEngineRef = useRef(null);
  const toolGroupRef = useRef(null); // ä¿å­˜å·¥å…·ç»„å¼•ç”¨
  const loadSeqRef = useRef(0); // åŠ è½½åºåˆ—ï¼Œç”¨äºé˜²æ­¢å¹¶å‘æ“ä½œå¯¼è‡´çš„å·²é”€æ¯å®ä¾‹è®¿é—®

  // æ‰“å°å¹¶ä¿å­˜å½“å‰æ³¨é‡Š/æµ‹é‡ JSON
  const printAnnotations = useCallback(async () => {
    try {
      const all =
        (csToolsAnnotation as any)?.state?.getAllAnnotations?.() || [];
      console.log("ğŸš€ ~ printAnnotations ~ all:", JSON.stringify(all));

      if (!id) {
        addToast({ color: "danger", description: "æ— æ•ˆçš„æ•°æ®IDï¼Œæ— æ³•ä¿å­˜" });
        return;
      }

      const res = await saveDcmAnnotationsRequest(Number(id), all);
      if (res.success) {
        addToast({ color: "success", description: "æ³¨é‡Šå·²ä¿å­˜" });
      } else {
        addToast({ color: "warning", description: res.message || "ä¿å­˜å¤±è´¥" });
      }
    } catch (e: any) {
      console.warn("æ— æ³•è·å–æˆ–ä¿å­˜æ³¨é‡Šæ•°æ®", e);
      addToast({ color: "danger", description: "ä¿å­˜å¤±è´¥" });
    }
  }, [id]);

  // åˆ‡æ¢åˆ°æŒ‡å®šå›¾åƒ
  const switchToImage = useCallback(
    async (index: number) => {
      if (isLoading || !renderingEngineRef.current || !imageIds[index]) return;

      try {
        setIsLoading(true);
        const renderingEngine = renderingEngineRef.current;
        const viewport = renderingEngine.getViewport("CT_SAGITTAL_STACK");

        if (viewport && typeof (viewport as any).setStack === "function") {
          // è®¾ç½®å•ä¸ªå›¾åƒ
          await (viewport as any).setStack([imageIds[index]]);
          if (typeof (viewport as any).resetCamera === "function") {
            (viewport as any).resetCamera();
          }
          renderingEngine.render();
          setCurrentImageIndex(index);
          console.log(`å·²åˆ‡æ¢åˆ°ç¬¬ ${index + 1} å¼ å›¾åƒ`);
        }
      } catch (error) {
        console.error("åˆ‡æ¢å›¾åƒå¤±è´¥:", error);
        setError("åˆ‡æ¢å›¾åƒå¤±è´¥: " + error.message);
      } finally {
        setIsLoading(false);
      }
    },
    [imageIds, isLoading]
  );

  // åˆ‡æ¢åˆ°ä¸Šä¸€å¼ å›¾åƒ
  const goToPreviousImage = useCallback(() => {
    if (isLoading || imageIds.length <= 1) return;
    const newIndex =
      currentImageIndex > 0 ? currentImageIndex - 1 : imageIds.length - 1;
    switchToImage(newIndex);
  }, [currentImageIndex, imageIds.length, isLoading, switchToImage]);

  // åˆ‡æ¢åˆ°ä¸‹ä¸€å¼ å›¾åƒ
  const goToNextImage = useCallback(() => {
    if (isLoading || imageIds.length <= 1) return;
    const newIndex =
      currentImageIndex < imageIds.length - 1 ? currentImageIndex + 1 : 0;
    switchToImage(newIndex);
  }, [currentImageIndex, imageIds.length, isLoading, switchToImage]);

  // åŠ è½½DCMæ•°æ®è¯¦æƒ…
  useEffect(() => {
    const loadDcmData = async () => {
      if (!id) {
        addToast({
          color: "danger",
          description: "æ•°æ®IDæ— æ•ˆ",
        });
        navigate("/list");
        return;
      }

      setDataLoading(true);
      try {
        const response = await getOriginalDataDetailRequest(Number(id));
        console.log("ğŸš€ ~ loadDcmData ~ response:", response);

        if (response.success && response.data) {
          setDcmData(response.data);

          // åˆå§‹åŒ–å›¾åƒ ID åˆ—è¡¨
          if (response.data.files && response.data.files.length > 0) {
            const ids = response.data.files.map((file) => {
              // ä½¿ç”¨æ–°çš„æ–‡ä»¶ç»“æ„ï¼Œç›´æ¥ä½¿ç”¨ fresh_url
              return `wadouri:${file.fresh_url}`;
            });
            setImageIds(ids);
            setCurrentImageIndex(0); // é‡ç½®åˆ°ç¬¬ä¸€å¼ å›¾
          }
        } else {
          addToast({
            color: "danger",
            description: response.message || "åŠ è½½æ•°æ®å¤±è´¥",
          });
          navigate("/list");
        }
      } catch (err) {
        console.error("åŠ è½½æ•°æ®é”™è¯¯:", err);
        addToast({
          color: "danger",
          description: "åŠ è½½æ•°æ®å¤±è´¥",
        });
        navigate("/list");
      } finally {
        setDataLoading(false);
      }
    };

    loadDcmData();
  }, [id, navigate]);

  // åˆå§‹åŒ– Cornerstone
  useEffect(() => {
    const initCornerstone = async () => {
      try {
        // åˆå§‹åŒ– cornerstone
        await csRenderInit();

        // ç¡®ä¿ dicomImageLoader.external å­˜åœ¨
        if (!(dicomImageLoader as any).external) {
          (dicomImageLoader as any).external = {};
        }

        // é…ç½® DICOM Image Loader
        (dicomImageLoader as any).external.cornerstone = cornerstone;
        (dicomImageLoader as any).external.dicomParser = dicomParser;

        // åˆå§‹åŒ– dicom image loader
        dicomImageLoaderInit();
        // ç¡®ä¿ wadouri åŠ è½½å™¨å·²æ³¨å†Œï¼ˆå¹‚ç­‰ï¼‰
        try {
          if (dicomImageLoader?.wadouri?.register) {
            dicomImageLoader.wadouri.register();
          }
        } catch (e) {
          console.warn("æ³¨å†Œ wadouri åŠ è½½å™¨æ—¶å‡ºé”™ï¼ˆå¯å¿½ç•¥ï¼‰", e);
        }

        // å¯é€‰ï¼šå¢åŠ  XHR è°ƒè¯•æ—¥å¿—ï¼Œä¾¿äºå®šä½â€œå¡åœ¨åŠ è½½ä¸­â€
        try {
          if ((dicomImageLoader as any)?.internal?.setOptions) {
            (dicomImageLoader as any).internal.setOptions({
              onloadstart: (_e: any, params: any) => {
                console.log("è¯·æ±‚å¼€å§‹", params?.url);
              },
              onprogress: (e: any, params: any) => {
                console.log("åŠ è½½è¿›åº¦", params?.url, e?.loaded, e?.total);
              },
              onreadystatechange: (e: any, params: any) => {
                const xhr = e?.target;
                console.log(
                  "readyState",
                  params?.url,
                  (xhr as any)?.readyState,
                  (xhr as any)?.status
                );
              },
              onloadend: (_e: any, params: any) => {
                console.log("è¯·æ±‚ç»“æŸ", params?.url);
              },
              beforeProcessing: (xhr: any) => Promise.resolve(xhr.response),
              errorInterceptor: (error: any) => {
                console.error("è¯·æ±‚é”™è¯¯", error);
              },
            });
          }
        } catch (e) {
          console.warn("è®¾ç½® dicomImageLoader è°ƒè¯•é€‰é¡¹å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰", e);
        }

        console.log(dicomImageLoader);
        // é…ç½® Web Workersï¼ˆç¦ç”¨ä»¥é¿å…åœ¨æ·±è·¯å¾„åˆ·æ–°æ—¶çš„ worker 404 é—®é¢˜ï¼‰
        try {
          (dicomImageLoader as any).configure({ useWebWorkers: false });
        } catch (e) {
          console.warn("é…ç½® dicomImageLoader å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰", e);
        }

        // åˆå§‹åŒ–å·¥å…·
        await csToolsInit();

        // æ·»åŠ å·¥å…·
        addTool(PanTool);
        addTool(WindowLevelTool);
        addTool(ZoomTool);
        addTool(LengthTool);
        addTool(RectangleROITool);
        addTool(EllipticalROITool);
        addTool(CircleROITool);
        addTool(ArrowAnnotateTool);
        addTool(ProbeTool);
        addTool(AngleTool);
        addTool(BidirectionalTool);
        addTool(PlanarFreehandROITool);
        addTool(CobbAngleTool);
        addTool(RectangleROIStartEndThresholdTool);
        addTool(RectangleROIThresholdTool);
        addTool(SplineROITool);
        addTool(LivewireContourTool);
        addTool(MagnifyTool);
        addTool(OverlayGridTool);
        addTool(ScaleOverlayTool);
        addTool(AdvancedMagnifyTool);
        addTool(UltrasoundDirectionalTool);
        addTool(RectangleScissorsTool);
        addTool(CircleScissorsTool);
        addTool(SphereScissorsTool);
        addTool(LabelTool);

        setIsInitialized(true);
        console.log("Cornerstone åˆå§‹åŒ–æˆåŠŸ");
      } catch (err) {
        console.error("Cornerstone åˆå§‹åŒ–å¤±è´¥:", err);
        setError("åˆå§‹åŒ–å¤±è´¥: " + err.message);
      }
    };

    initCornerstone();

    // æ¸…ç†å‡½æ•°
    return () => {
      try {
        // æ¸…ç†æ¸²æŸ“å¼•æ“
        if (renderingEngineRef.current) {
          renderingEngineRef.current.destroy();
          renderingEngineRef.current = null;
        }

        // æ¸…ç†å·¥å…·ç»„
        const toolGroupId = "STACK_TOOL_GROUP_ID";
        try {
          const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);
          if (toolGroup) {
            ToolGroupManager.destroyToolGroup(toolGroupId);
          }
        } catch (e) {
          console.warn("æ¸…ç†å·¥å…·ç»„æ—¶å‡ºé”™ï¼ˆå¯å¿½ç•¥ï¼‰:", e);
        }
      } catch (e) {
        console.warn("ç»„ä»¶æ¸…ç†æ—¶å‡ºé”™ï¼ˆå¯å¿½ç•¥ï¼‰:", e);
      }
    };
  }, []);

  // åŠ è½½å’Œæ¸²æŸ“ DICOM æ–‡ä»¶
  const loadDicomFile = useCallback(async () => {
    if (!isInitialized || !elementRef.current || !dcmData) return;

    setIsLoading(true);
    setError(null);
    const seq = ++loadSeqRef.current;

    try {
      const element = elementRef.current;

      // æ¸…ç†ä¹‹å‰çš„æ¸²æŸ“å¼•æ“
      if (renderingEngineRef.current) {
        try {
          renderingEngineRef.current.destroy();
        } catch (e) {
          console.warn("æ¸…ç†æ¸²æŸ“å¼•æ“æ—¶å‡ºé”™ï¼ˆå¯å¿½ç•¥ï¼‰:", e);
        }
        renderingEngineRef.current = null;
      }

      // åˆ›å»ºæ¸²æŸ“å¼•æ“
      const renderingEngineId = "myRenderingEngine";
      const renderingEngine = new RenderingEngine(renderingEngineId);
      renderingEngineRef.current = renderingEngine;

      // åˆ›å»ºè§†å£
      const viewportId = "CT_SAGITTAL_STACK";
      const viewportInput = {
        viewportId,
        type: ViewportType.STACK,
        element,
        defaultOptions: {
          background: [0, 0, 0] as [number, number, number],
        },
      };

      renderingEngine.enableElement(viewportInput);

      // ç­‰å¾…DOMæ›´æ–°åè°ƒæ•´å°ºå¯¸
      setTimeout(() => {
        try {
          if (seq !== loadSeqRef.current) return;
          renderingEngine.resize(true);
          const vp = renderingEngine.getViewport(viewportId);
          if (vp && typeof (vp as any).resetCamera === "function") {
            (vp as any).resetCamera();
          }
          renderingEngine.render();
        } catch (e) {
          console.warn("è°ƒæ•´æ¸²æŸ“å¼•æ“å°ºå¯¸å¤±è´¥:", e);
        }
      }, 50);

      // è·å–è§†å£
      const viewport = renderingEngine.getViewport(viewportId);

      // åˆ›å»ºå·¥å…·ç»„ - æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
      const toolGroupId = "STACK_TOOL_GROUP_ID";
      let toolGroup;

      try {
        // å°è¯•è·å–å·²å­˜åœ¨çš„å·¥å…·ç»„
        toolGroup = ToolGroupManager.getToolGroup(toolGroupId);
        if (toolGroup) {
          // å¦‚æœå·¥å…·ç»„å·²å­˜åœ¨ï¼Œå…ˆé”€æ¯å®ƒ
          ToolGroupManager.destroyToolGroup(toolGroupId);
        }
      } catch (e) {
        // å·¥å…·ç»„ä¸å­˜åœ¨ï¼Œç»§ç»­åˆ›å»ºæ–°çš„
        console.log("å·¥å…·ç»„ä¸å­˜åœ¨ï¼Œå°†åˆ›å»ºæ–°çš„");
      }

      // åˆ›å»ºæ–°çš„å·¥å…·ç»„
      toolGroup = ToolGroupManager.createToolGroup(toolGroupId);
      toolGroupRef.current = toolGroup; // ä¿å­˜å·¥å…·ç»„å¼•ç”¨

      // æ·»åŠ å·¥å…·åˆ°å·¥å…·ç»„
      toolGroup.addTool(WindowLevelTool.toolName);
      toolGroup.addTool(PanTool.toolName);
      toolGroup.addTool(ZoomTool.toolName);
      toolGroup.addTool(LengthTool.toolName);
      toolGroup.addTool(RectangleROITool.toolName);
      toolGroup.addTool(EllipticalROITool.toolName);
      toolGroup.addTool(CircleROITool.toolName);
      toolGroup.addTool(ArrowAnnotateTool.toolName);
      toolGroup.addTool(ProbeTool.toolName);
      toolGroup.addTool(AngleTool.toolName);
      toolGroup.addTool(BidirectionalTool.toolName);
      toolGroup.addTool(PlanarFreehandROITool.toolName);
      toolGroup.addTool(CobbAngleTool.toolName);
      toolGroup.addTool(RectangleROIStartEndThresholdTool.toolName);
      toolGroup.addTool(RectangleROIThresholdTool.toolName);
      toolGroup.addTool(SplineROITool.toolName);
      toolGroup.addTool(LivewireContourTool.toolName);
      toolGroup.addTool(MagnifyTool.toolName);
      toolGroup.addTool(OverlayGridTool.toolName);
      toolGroup.addTool(ScaleOverlayTool.toolName);
      toolGroup.addTool(AdvancedMagnifyTool.toolName);
      toolGroup.addTool(UltrasoundDirectionalTool.toolName);
      toolGroup.addTool(RectangleScissorsTool.toolName);
      toolGroup.addTool(CircleScissorsTool.toolName);
      toolGroup.addTool(SphereScissorsTool.toolName);
      toolGroup.addTool(LabelTool.toolName);

      // è®¾ç½®å·¥å…·ä¸ºæ¿€æ´»çŠ¶æ€
      toolGroup.setToolActive(WindowLevelTool.toolName, {
        bindings: [{ mouseButton: MouseBindings.Primary }],
      });
      toolGroup.setToolActive(PanTool.toolName, {
        bindings: [{ mouseButton: MouseBindings.Auxiliary }],
      });
      toolGroup.setToolActive(ZoomTool.toolName, {
        bindings: [{ mouseButton: MouseBindings.Secondary }],
      });

      // å°†å·¥å…·ç»„æ·»åŠ åˆ°è§†å£
      toolGroup.addViewport(viewportId, renderingEngineId);

      // åŠ è½½å›¾åƒ - ä½¿ç”¨çŠ¶æ€ä¸­çš„imageIds
      let currentImageIds: string[] = [];

      if (imageIds.length > 0) {
        // ä½¿ç”¨å·²åŠ è½½çš„å›¾åƒ IDï¼Œåªæ˜¾ç¤ºå½“å‰å›¾åƒ
        currentImageIds = [imageIds[currentImageIndex]];
      } else if (dcmData.files && dcmData.files.length > 0) {
        // å¦‚æœçŠ¶æ€ä¸­è¿˜æ²¡æœ‰imageIdsï¼Œä½¿ç”¨dcmDataæ„å»º
        const allImageIds = dcmData.files.map((file) => {
          return `wadouri:${file.file_url}`;
        });
        // åŒæ—¶æ›´æ–°çŠ¶æ€
        setImageIds(allImageIds);
        currentImageIds = [allImageIds[0]]; // åªæ˜¾ç¤ºç¬¬ä¸€å¼ 
      } else {
        // å¦‚æœæ²¡æœ‰æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤çš„æµ‹è¯•æ–‡ä»¶
        const imageId = "wadouri:/3.dcm";
        currentImageIds = [imageId];
      }

      console.log("åŠ è½½å›¾åƒ ID:", currentImageIds);

      // è®¾ç½®å›¾åƒå †æ ˆï¼ˆåªæ˜¾ç¤ºå½“å‰å›¾åƒï¼‰
      if (seq !== loadSeqRef.current) return;
      await (viewport as any).setStack(currentImageIds);
      if (typeof (viewport as any).resetCamera === "function") {
        (viewport as any).resetCamera();
      }

      // æ¸²æŸ“
      if (seq !== loadSeqRef.current) return;
      renderingEngine.render();

      console.log("DICOM æ–‡ä»¶åŠ è½½æˆåŠŸ");
    } catch (err) {
      console.error("åŠ è½½ DICOM æ–‡ä»¶å¤±è´¥:", err);
      setError("åŠ è½½å¤±è´¥: " + err.message);
    } finally {
      if (seq === loadSeqRef.current) setIsLoading(false);
    }
  }, [isInitialized, dcmData, imageIds, currentImageIndex]);

  // åˆ‡æ¢å·¥å…·
  const switchTool = useCallback((toolName) => {
    if (!toolGroupRef.current) return;

    try {
      const toolGroup = toolGroupRef.current;

      // å…ˆå°†æ‰€æœ‰å·¥å…·è®¾ä¸ºéæ¿€æ´»çŠ¶æ€
      toolGroup.setToolPassive(WindowLevelTool.toolName);
      toolGroup.setToolPassive(PanTool.toolName);
      toolGroup.setToolPassive(ZoomTool.toolName);
      toolGroup.setToolPassive(LengthTool.toolName);
      toolGroup.setToolPassive(RectangleROITool.toolName);
      toolGroup.setToolPassive(EllipticalROITool.toolName);
      toolGroup.setToolPassive(CircleROITool.toolName);
      toolGroup.setToolPassive(ArrowAnnotateTool.toolName);
      toolGroup.setToolPassive(ProbeTool.toolName);
      toolGroup.setToolPassive(AngleTool.toolName);
      toolGroup.setToolPassive(BidirectionalTool.toolName);
      toolGroup.setToolPassive(PlanarFreehandROITool.toolName);
      toolGroup.setToolPassive(CobbAngleTool.toolName);
      toolGroup.setToolPassive(RectangleROIStartEndThresholdTool.toolName);
      toolGroup.setToolPassive(RectangleROIThresholdTool.toolName);
      toolGroup.setToolPassive(SplineROITool.toolName);
      toolGroup.setToolPassive(LivewireContourTool.toolName);
      toolGroup.setToolPassive(MagnifyTool.toolName);
      toolGroup.setToolPassive(OverlayGridTool.toolName);
      toolGroup.setToolPassive(ScaleOverlayTool.toolName);
      toolGroup.setToolPassive(AdvancedMagnifyTool.toolName);
      toolGroup.setToolPassive(UltrasoundDirectionalTool.toolName);
      toolGroup.setToolPassive(RectangleScissorsTool.toolName);
      toolGroup.setToolPassive(CircleScissorsTool.toolName);
      toolGroup.setToolPassive(SphereScissorsTool.toolName);
      toolGroup.setToolPassive(LabelTool.toolName);

      // æ¿€æ´»é€‰ä¸­çš„å·¥å…·
      switch (toolName) {
        case "WindowLevel":
          toolGroup.setToolActive(WindowLevelTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Pan":
          toolGroup.setToolActive(PanTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Zoom":
          toolGroup.setToolActive(ZoomTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Length":
          toolGroup.setToolActive(LengthTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "RectangleROI":
          toolGroup.setToolActive(RectangleROITool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "EllipticalROI":
          toolGroup.setToolActive(EllipticalROITool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "CircleROI":
          toolGroup.setToolActive(CircleROITool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "ArrowAnnotate":
          toolGroup.setToolActive(ArrowAnnotateTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Probe":
          toolGroup.setToolActive(ProbeTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Angle":
          toolGroup.setToolActive(AngleTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Bidirectional":
          toolGroup.setToolActive(BidirectionalTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "PlanarFreehandROI":
          toolGroup.setToolActive(PlanarFreehandROITool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "CobbAngle":
          toolGroup.setToolActive(CobbAngleTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "RectangleROIStartEndThreshold":
          toolGroup.setToolActive(RectangleROIStartEndThresholdTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "RectangleROIThreshold":
          toolGroup.setToolActive(RectangleROIThresholdTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "SplineROI":
          toolGroup.setToolActive(SplineROITool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "LivewireContour":
          toolGroup.setToolActive(LivewireContourTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Magnify":
          toolGroup.setToolActive(MagnifyTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "OverlayGrid":
          toolGroup.setToolActive(OverlayGridTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "ScaleOverlay":
          toolGroup.setToolActive(ScaleOverlayTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "AdvancedMagnify":
          toolGroup.setToolActive(AdvancedMagnifyTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "UltrasoundDirectional":
          toolGroup.setToolActive(UltrasoundDirectionalTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "RectangleScissors":
          toolGroup.setToolActive(RectangleScissorsTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "CircleScissors":
          toolGroup.setToolActive(CircleScissorsTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "SphereScissors":
          toolGroup.setToolActive(SphereScissorsTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
        case "Label":
          toolGroup.setToolActive(LabelTool.toolName, {
            bindings: [{ mouseButton: MouseBindings.Primary }],
          });
          break;
      }

      setActiveTool(toolName);
      console.log(`å·²åˆ‡æ¢åˆ°å·¥å…·: ${toolName}`);
    } catch (error) {
      console.error("åˆ‡æ¢å·¥å…·å¤±è´¥:", error);
    }
  }, []);

  // é‡ç½®è§†å›¾
  const resetView = useCallback(() => {
    if (!renderingEngineRef.current) return;

    try {
      const renderingEngine = renderingEngineRef.current;
      const viewport = renderingEngine.getViewport("CT_SAGITTAL_STACK");

      if (viewport && typeof (viewport as any).resetCamera === "function") {
        (viewport as any).resetCamera();
        renderingEngine.render();
        console.log("å·²é‡ç½®è§†å›¾");
      }
    } catch (error) {
      console.error("é‡ç½®è§†å›¾å¤±è´¥:", error);
    }
  }, []);

  // åˆå§‹åŒ–å®Œæˆåè‡ªåŠ¨åŠ è½½ï¼ˆå–æ¶ˆä¸Šä¸€æ¬¡æœªå®Œæˆçš„åŠ è½½ï¼‰
  useEffect(() => {
    if (isInitialized && dcmData && !dataLoading) {
      // ç­‰å¾…DOMå…ƒç´ æ¸²æŸ“å®Œæˆ
      setTimeout(() => {
        loadSeqRef.current++;
        loadDicomFile();
      }, 100);
    }
  }, [isInitialized, dcmData, dataLoading, loadDicomFile]);

  // é”®ç›˜å¿«æ·é”®æ”¯æŒ
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (isLoading || imageIds.length <= 1) return;

      switch (event.key) {
        case "ArrowLeft":
          event.preventDefault();
          goToPreviousImage();
          break;
        case "ArrowRight":
          event.preventDefault();
          goToNextImage();
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [imageIds.length, goToPreviousImage, goToNextImage]);

  // ç›‘å¬çª—å£å°ºå¯¸å˜åŒ–ï¼Œè°ƒæ•´è§†å£å¤§å°
  useEffect(() => {
    const handleResize = () => {
      if (renderingEngineRef.current && elementRef.current) {
        try {
          setTimeout(() => {
            const renderingEngine = renderingEngineRef.current;
            if (renderingEngine) {
              renderingEngine.resize(true);
              renderingEngine.render();
            }
          }, 100);
        } catch (error) {
          console.warn("è°ƒæ•´è§†å£å°ºå¯¸å¤±è´¥:", error);
        }
      }
    };

    window.addEventListener("resize", handleResize);

    // åˆå§‹åŒ–æ—¶ä¹Ÿè°ƒç”¨ä¸€æ¬¡
    if (isInitialized) {
      setTimeout(handleResize, 200);
    }

    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [isInitialized]);

  return (
    <div className="h-screen flex flex-col">
      <TopBar
        title={
          dataLoading ? "DICOM å›¾åƒæŸ¥çœ‹å™¨" : dcmData?.name || "DICOM å›¾åƒæŸ¥çœ‹å™¨"
        }
        isInitialized={!!isInitialized}
        isLoading={!!isLoading}
        hasData={!!dcmData}
        onBack={() => navigate("/list")}
        onReload={loadDicomFile}
        onReset={resetView}
        onConsoleEditData={printAnnotations}
      />
      <ToolBar
        isInitialized={!!isInitialized}
        activeTool={activeTool}
        onSwitch={switchTool}
      />

      <StatusBanners
        error={error}
        dataLoading={dataLoading}
        isInitialized={isInitialized}
      />

      <ViewerCanvas
        elementRef={elementRef}
        isLoading={isLoading}
        isInitialized={isInitialized}
        hasData={!!dcmData}
        showSwitchHint={imageIds.length > 1}
      />

      <ImageSwitcher
        visible={!!dcmData && imageIds.length > 1}
        isLoading={isLoading}
        imageCount={imageIds.length}
        currentIndex={currentImageIndex}
        expanded={isImageControlExpanded}
        onToggleExpanded={() =>
          setIsImageControlExpanded(!isImageControlExpanded)
        }
        onPrev={goToPreviousImage}
        onNext={goToNextImage}
        onJump={(index) => switchToImage(index)}
        currentFileName={dcmData?.files[currentImageIndex]?.file_name}
      />
    </div>
  );
}

export default DetailPage;
